{"meta":{"title":"凡所有相，皆是虚妄。若见诸相非相，即见如来","subtitle":null,"description":null,"author":"影风","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"CentOS搭建Redis集群","slug":"CentOS搭建Redis集群","date":"2018-04-28T16:58:48.000Z","updated":"2019-04-29T06:24:33.744Z","comments":false,"path":"2018/04/29/CentOS搭建Redis集群/","link":"","permalink":"http://yoursite.com/2018/04/29/CentOS搭建Redis集群/","excerpt":"","text":"下载源码并解压编译123456789yum -y install gcc automake autoconf libtool make rubymkdir -p /usr/local/rediscd /usr/local/rediswget http://download.redis.io/releases/redis-5.0.0.tar.gztar xzf redis-5.0.0.tar.gzcd redis-5.0.0make MALLOC=libc 创建Redis配置文件1234567891011121314151617181920mkdir -p /usr/local/redis/redis-cluster-conf/7001mkdir -p /usr/local/redis/redis-cluster-conf/7002mkdir -p /usr/local/redis/redis-cluster-conf/7003mkdir -p /usr/local/redis/redis-cluster-conf/7004mkdir -p /usr/local/redis/redis-cluster-conf/7005mkdir -p /usr/local/redis/redis-cluster-conf/7006vim redis.conf## 配置文件的内容为：## 其中 port 和 pidfile 需要随着 文件夹的不同调增。port 7001bind 192.168.6.223cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000appendonly yesdaemonize yesprotected-mode nopidfile /var/run/redis_7001.pid 启动节点12345678/usr/local/redis/redis-5.0.0/src/redis-server /usr/local/redis/redis-cluster-conf/7001/redis.conf/usr/local/redis/redis-5.0.0/src/redis-server /usr/local/redis/redis-cluster-conf/7002/redis.conf/usr/local/redis/redis-5.0.0/src/redis-server /usr/local/redis/redis-cluster-conf/7003/redis.conf/usr/local/redis/redis-5.0.0/src/redis-server /usr/local/redis/redis-cluster-conf/7004/redis.conf/usr/local/redis/redis-5.0.0/src/redis-server /usr/local/redis/redis-cluster-conf/7005/redis.conf/usr/local/redis/redis-5.0.0/src/redis-server /usr/local/redis/redis-cluster-conf/7006/redis.conf## 按顺序执行，启动完之后通过ps -ef|grep redis命令查看启动的进程 启动集群1234## 3个master 3个slave/usr/local/redis/redis-5.0.0/src/redis-cli --cluster create 192.168.6.223:7001 192.168.6.223:7002 192.168.6.223:7003 192.168.6.223:7004 192.168.6.223:7005 192.168.6.223:7006 --cluster-replicas 1type yes 连接集群12345./redis-cli -h 192.168.6.223 -c -p 7001## 测试在7001上set a \"yjj\"在7003上get a 集群密码设置12345678## 每个节点都要设置config set masterauth abc123config set requirepass abc123auth abc123config rewrite## 带密码登录./redis-cli -h 192.168.6.223 -c -p 7001 -a abc123","categories":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/categories/运维/"}],"tags":[{"name":"集群","slug":"集群","permalink":"http://yoursite.com/tags/集群/"}],"keywords":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/categories/运维/"}]},{"title":"MySQL数据库常见优化","slug":"MySQL数据库常见优化","date":"2018-04-27T08:36:36.000Z","updated":"2019-05-07T02:22:22.712Z","comments":false,"path":"2018/04/27/MySQL数据库常见优化/","link":"","permalink":"http://yoursite.com/2018/04/27/MySQL数据库常见优化/","excerpt":"","text":"MySQL分区特点在逻辑上为一个表，在物理上存储在多个文件中 为什么要分区 分区可以在一个表中存储比单个磁盘或文件系统分区上的数据更多的数据，因为我们可以将分区表存储在不同物理磁盘上 对已过期或者不需要保存的数据，可以通过删除与这些数据有关的分区来快速删除数据，他的效率远比delete高 优化查询，在where子句中包含分区条件时，可以只扫描必要的一个或者多个分区来提高查询效率例：SELECT * FROM t PARTITION（p0，p1）WHERE c仅选择与WHERE条件匹配的分区p0和p1中的那些行在这种情况下，MySQL不检查表t的任何其他分区 涉及聚合函数SUM()、COUNT()的查询时，可以容易的在每个分区上并行处理例：SELECT salesperson_id，COUNT（orders）as order_total FROM sales GROUP BY salesperson_id会在每个分区上都同时运行查询 凭借在多个磁盘上传播数据，实现更高的查询吞吐量 缺点一个表最多只能有1024个分区，同一个分区表的所有分区必须使用相同存储引擎，分区表无法使用外键约束 3种常用分区类型HASH分区 根据MOD（分区键，分区数）的值把数据行存储到表的不同分区中 数据可以平均的分布在各个分区表中 HASH分区的键值必须是一个INT类型的值，或是通过函数可以转为INT类型12345678910111213141516171819202122CREATE TABLE `login_log` ( `id` int(10) unsigned NOT NULL, `login_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `login_ip` int(10) unsigned NOT NULL, `login_type` tinyint(4) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4PARTITION BY HASH (id)PARTITIONS 4CREATE TABLE `login_log` ( `id` int(10) unsigned NOT NULL, `login_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `login_ip` int(10) unsigned NOT NULL, `login_type` tinyint(4) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4PARTITION BY HASH (UNIX_TIMESTAMP(login_time))PARTITIONS 4USE information_schema;SELECT PARTITION_NAME,TABLE_ROWSFROM INFORMATION_SCHEMA.PARTITIONSWHERE TABLE_NAME = 'login_log'; RANGE分区 根据分区键值的范围把数据行存储到表的不同分区中 多个分区的范围要连续，但是不能重叠 默认情况下使用VALUES LESS THAN属性，即每个分区不包括指定的那个值 使用场景 分区键为日期或时间类型 所有查询中都包括分区键 定期按分区范围清理历史数据123456789101112CREATE TABLE `login_log` ( `id` int(10) unsigned NOT NULL, `login_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `login_ip` int(10) unsigned NOT NULL, `login_type` tinyint(4) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4PARTITION BY RANGE (id) ( PARTITION p0 VALUES LESS THAN (3), PARTITION p1 VALUES LESS THAN (6), PARTITION p2 VALUES LESS THAN (9), PARTITION p4 VALUES LESS THAN MAXVALUE) LIST分区 按分区键取值的列表进行分区 同范围分区一样，各分区的列表值不能重复 每一行数据必须能找到对应的分区列表，否则数据无法插入12345678910111213141516CREATE TABLE `login_log` ( `id` int(10) unsigned NOT NULL, `login_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `login_ip` int(10) unsigned NOT NULL, `login_type` tinyint(4) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4PARTITION BY LIST (login_type) ( PARTITION p0 VALUES IN (1,2,3), PARTITION p1 VALUES IN (4,5,6))/*删除分区*/ALTER TABLE login_log DROP PARTITION p0/*迁移分区数据*/ALTER TABLE login_log EXCHAGE PARTITION p1 with TABLE arch_login_log 注意事项 结合业务场景选择分区方式，应避免跨分区查询 对分区表查询最好在WHERE从句中包含分区键 具有主键或唯一索引的表，主键或唯一索引必须是分区键的一部分 执行计划explain结果分析ID列 ID列表示SELECT语句的顺序 ID值相同时，执行顺序由上至下 ID值越大优先级越高，越先被执行 SELECT_TYPE列 SIMPLE：不包含子查询或UNION操作的查询 PRIMARY：查询中如果包含子查询，那么最外层的查询被标记为PRIMARY SUBQUERY：SEL ECT列表中的子查询 DEPENDENT SUBQUERY：依赖外部结果的子查询 UNION：UNION操作的第二个或是之后的查询的值为UNION DEPENDENT UNION：当UNION作为子查询时，第二或是第二个后的查询 UNION RESULT：UNION产生的结果集 DERIVED：出现在FROM子句中的子查询 TABLE列 输出数据行所在的表名称 PARTITIONS列 对于分区表，显示查询的分区ID 对于非分区表，显示为NULL TYPE列性能由高到低排列 system：const联接类型的一个特例当查询的表只有一行时使用 const：表中有且只有一个匹配的行时使用,如对主键或是唯一索引的查询最高的联接方式 eq_ref：唯一索或主键引查找,对于每个索引键,表中只有一条记录与之匹配 ref：非唯一索引查找,返回匹配某个单独值的所有行。 ref_or_null：类似于ref类型的查询,但是附加了对NULL值列的查询 index_merge：该联接类型表示使用了索引合并优化方法 range：索引范围扫描,常见于between, &gt;、&lt;这样的查询条件 index：全索引扫描,同ALL的区别是,遍历的是索引树 ALL：全表扫描,这是效率最差的联接方式 Extra列 Distinct：优化distinct操作,在找到第一匹配的元组后即停止找同样值的动作 Not exists：使用not exists来优化查询 Using filesort：使用额外操作进行排序，通常会出现在order by或group by查询 Using index：使用了覆盖索引进行查询 Using temporary：使用临时表来处理查询，常见于排序，子查询和分组查询 Using where：使用WHERE条件来过滤数据 select tables optimized away：直接通过索引来获得数据，不用访问表 POSSIBLE_KEYS列 指出MySQL能使用那些索引来优化查询 查询列所涉及到的列上的索引都会被列出,但不一定会被使用 KEY列 查询优化器优化查询实际所使用的索引 如果没有可用的索引，则显示为NULL 如查询使用了覆盖索引，则该索引仅出现在Key中 KEY_LEN列 表示索引字段的最大可能长度 KEY_LEN的长度由字段定义计算而来，并非数据的实际长度 Ref列 表示列或常量被用于查找索引列上的值 rows列 表示MySQL通过索引统计信息，估算的所需读取的行数 rows值的大小是个统计抽样结果，并不十分准确 Filtered列 表示返回结果的行数占需读取行数的百分比 Filtered列的值越大越好 Filtered列的值依赖统计信息 限制 无法展示存储过程、触发器、UDF对查询的影响 无法使用EXPLAIN对存储过程进行分析 早起版本的MySQL只支持SELECT语句 分页查询优化1234567891011select product_info.supplier_id, product_info.product_name, product_supplier_info.supplier_namefrom product_infoleft join product_supplier_infoon product_info.supplier_id = product_supplier_info.supplier_id limit 100, 500alter table product_info add index idx_supplier_id (supplier_id)/*增加联合索引达到覆盖索引效果*/alter table product_info add index idx_product_name_supplier_id (supplier_id, product_name)alter table product_supplier_info add index idx_supplier_name_supplier_id (supplier_id, supplier_name) 慢查询日志1234567891011121314/*查看是否开启了慢查询日志*/show variables like '%slow_query_log%'/*开启慢查询日志*/set global slow_query_log = on;/*未使用索引的查询也被记录到慢查询日志中*/set global log_queries_not_using_indexes = on;/*慢查询日志存储路径*/set global slow_query_log_file = '/var/lib/mysql/slow_query.log';/*当查询时间多于设定的阈值时，记录日志*/set global long_query_time = 0.001;/*shell 查看慢查询日志*/mysqldumpslow 3de27981f248-slow.log 123456789#!/bin/bashtime=`date -d yesterday + \"%Y-%m-%d\"`host=\"127.0.0.1\"user=\"root\"passwd=\"123456\"#提前创建好一个存放目录：/var/lib/mysql/slow_log/mv /var/lib/mysql/slow_query.log /var/lib/mysql/slow_log/slow_query_$time.logmysql -u$user -p$passwd -e \"set global slow_query_log_file='/var/lib/mysql/slow_query.log';\"### 每天0点执行该脚本","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}]},{"title":"MySQL数据库设计规范","slug":"MySQL数据库设计规范","date":"2018-04-26T08:36:36.000Z","updated":"2019-04-26T09:27:22.895Z","comments":false,"path":"2018/04/26/MySQL数据库设计规范/","link":"","permalink":"http://yoursite.com/2018/04/26/MySQL数据库设计规范/","excerpt":"","text":"数据库命名规范 所有数据库对象名称必须小写 命名要做到见名识意，禁止使用MySQL保留关键字 临时表以tmp_开头，备份表以bak_开头并以时间戳结尾 所有存储相同数据的列名和列类型必须一致 数据库基本设计规范 所有表必须使用Innodb存储引擎 支持事务，行级锁，更好的恢复性，高并发下性能更好 show engines; 数据库和表的字符集统一使用UTF-8 避免由于字符集转换产生乱码 汉字占3个字节，ASCII码占1个字节 所有表和字段必须添加注释 尽量控制单表数据量的大小，建议控制在500万行以内 可以用历史数据归档，分库分表等手段来控制数据量大小 谨慎使用MySQL分区表 分区表在物理上表现为多个文件，在逻辑上表现为一个表 跨分区查询效率会低 建议采用物理分表的方式管理大数据 尽量做到冷热数据分离，减小表宽度 减少磁盘I/O，保证热数据的内存缓存命中率 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中 禁止在表中建立预留字段 禁止在数据库中存储图片，文件等二进制数据 禁止在线上做数据库压力测试 禁止从开发环境、测试环境直连生产环境数据库 数据库索引设计规范 限制每张表上的索引数量，建议单张表索引不超过5个 禁止给表中的每一列都建立单独的索引 每张表都必须有一个主键 不使用更新频繁的列作为主键 不使用多列主键 不使用UUID，MD5，HASH，字符串作为主键 主键建议使用自增id值 WHERE从句、ORDER BY、GROUP BY、DISTINCT、多表JOIN中的列优先设置索引 设置索引列的顺序 区分度最高的列放在联合索引的最左侧 尽量把字段长度小的列放在联合索引的最左侧 使用最频繁的列放到联合索引的左侧 避免建立冗余索引和重复索引 primary key(id)、index(id)、unique index(id) index(a,b,c)、index(a,b)、index(a) 对于频繁的查询优先考虑使用覆盖索引 避免Innodb表进行索引的二次查找 可以把随机I/O变为顺序I/O加快查询效率 尽量避免使用外键 外键可用于保证数据的参照完整性，但建议在业务端实现 外键会影响父表和子表的写操作从而降低性能 数据库字段设计规范 优先选择符合存储需要的最小的数据类型 将字符串转化为数字类型存储，INET_ATON(‘255.255.255.255’)，INET_NTOA(4294967295) 对于非负整数应采用无符号整型进行存储 VARCHAR(N)中的N指定要明确，过大的长度会消耗更多的内存 避免使用TEXT、BLOB数据类型 建议把BLOB或者TEXT分离到单独的扩展表中 TEXT或BLOB类型只能使用前缀索引 避免使用ENUM数据类型 尽可能把所有列定义为NOT NULL 索引NULL列需要额外的空间来保存 进行比较和计算要对NULL值做特别的处理 不要用字符串存储日期类型的数据 无法用日期函数进行计算和比较 用字符串存储日期要占更多的空间 使用TIMESTAMP或DATETIME类型存储时间 TIMESTAMP占用4字节和INT相同，但比INT可读性高 超出TIMESTAMP取值范围的时候用DATETIME TIMESTAMP 1970～01～01 ～ 2038-01-19 财务相关的金额类数据，必须使用decimal类型 SQL开发规范 建议使用预编译语句进行数据库操作 避免数据类型的隐式转换 select phone from user where id = ‘1’ 充分利用表上已经存在的索引 避免使用双%号的查询条件 使用left join 或 not exists 优化not in操作 禁止跨库查询 禁止使用SELECT *，必须使用SELECT &lt;字段列表&gt; 查询 禁止使用不含字段列表的INSERT语句 避免使用子查询，可以把子查询优化为join操作 避免使用JOIN关联太多的表，建议不超过5个 合并多个相同操作到一起，减少同数据库交互次数 使用in代替or，in的值不要超过500，in操作可以利用索引 禁止使用order by rand() 进行随机排序 WHERE从句中禁止队列进行函数转换和计算 where date(time) = ‘20160901’ where createtime &gt;= ‘20160901’ and createtime &lt; ‘20160902’ 在明显不会有重复值时使用UNION ALL，而不是UNION 拆分复杂的大SQL为多个小SQL 一个SQL只能使用一个CPU进行计算 数据库操作规范 超过100万行的批量写操作，要分批多次进行操作 大批量操作可能会造成严重的主从延迟 binlog日志为ROW格式会产生大量的日志 避免产生大事务操作 对大表数据结构的修改要谨慎，会造成严重的锁表操作 使用pt-online-schema-change修改表结构 禁止为程序使用的账号赋予super权限 程序使用的账号原则上不准有drop权限","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}]}]}